/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package projetoso1;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JOptionPane;

/**
 *
 * @author Lucas e Douglas
 */
public class Tela extends javax.swing.JFrame {

    String nome = "C:\\Users\\Lucas.Nunes-PC\\Documents\\NetBeansProjects\\ProjetoSO1\\build\\classes\\projetoso1\\dadosDisco.txt";
    String linha = "";			//Variável auxiliar que captura a linha do arquivo;
    int nSetores = 0;			//Número de Setores do HD
    int pInicial = 0;			//Posição inicial do braço do HD
    int trilha = 0;			//Indica a trilha do HD
    int i = 1;
    int somatorio = 0;
    int j = 0;
    int auxTrilhaTemp = 0;
    int init = 0;
    int difTrilhas2 = 0;
    List<Integer> trilhasPercorridas = new ArrayList<Integer>();
    List<Integer> difTrilhas = new ArrayList<Integer>();
    boolean carregou = false;
    boolean executou = false;

    /**
     * Creates new form Tela
     */
    public Tela() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        buttonGroup2 = new javax.swing.ButtonGroup();
        buttonGroup3 = new javax.swing.ButtonGroup();
        ButtonFCFS = new javax.swing.JRadioButton();
        ButtonSSF = new javax.swing.JRadioButton();
        ButtonElevator = new javax.swing.JRadioButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        Processos = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        CarregarProcessos = new javax.swing.JButton();
        Executar = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        TrilhasPercorridas = new javax.swing.JTextPane();
        Limpar = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setResizable(false);

        buttonGroup1.add(ButtonFCFS);
        ButtonFCFS.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        ButtonFCFS.setForeground(new java.awt.Color(255, 0, 0));
        ButtonFCFS.setText("FCFS");

        buttonGroup1.add(ButtonSSF);
        ButtonSSF.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        ButtonSSF.setForeground(new java.awt.Color(0, 0, 255));
        ButtonSSF.setText("SSF");

        buttonGroup1.add(ButtonElevator);
        ButtonElevator.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        ButtonElevator.setText("Elevator");

        Processos.setEditable(false);
        Processos.setColumns(20);
        Processos.setRows(5);
        jScrollPane1.setViewportView(Processos);

        jLabel1.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel1.setText("Processos");

        CarregarProcessos.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        CarregarProcessos.setText("Carregar");
        CarregarProcessos.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CarregarProcessosActionPerformed(evt);
            }
        });

        Executar.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        Executar.setText("Executar");
        Executar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExecutarActionPerformed(evt);
            }
        });

        jLabel2.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        jLabel2.setText("TrilhasPercorridas:");

        TrilhasPercorridas.setEditable(false);
        TrilhasPercorridas.setFont(new java.awt.Font("Times New Roman", 0, 14)); // NOI18N
        jScrollPane2.setViewportView(TrilhasPercorridas);

        Limpar.setFont(new java.awt.Font("Times New Roman", 1, 14)); // NOI18N
        Limpar.setText("Limpar");
        Limpar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LimparActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(ButtonFCFS)
                                .addGap(18, 18, 18)
                                .addComponent(ButtonSSF)
                                .addGap(18, 18, 18)
                                .addComponent(ButtonElevator))
                            .addComponent(jLabel1)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 241, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 23, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(CarregarProcessos)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(Executar)
                        .addGap(90, 90, 90)
                        .addComponent(Limpar)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ButtonFCFS)
                    .addComponent(ButtonSSF)
                    .addComponent(ButtonElevator))
                .addGap(34, 34, 34)
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(0, 230, Short.MAX_VALUE))
                            .addComponent(jScrollPane1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(CarregarProcessos)
                            .addComponent(Executar)
                            .addComponent(Limpar))
                        .addGap(19, 19, 19))))
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    private void CarregarProcessosActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CarregarProcessosActionPerformed
        if (!ButtonFCFS.isSelected() && !ButtonSSF.isSelected() && !ButtonElevator.isSelected()) {
            JOptionPane.showMessageDialog(null, "Selecione um algoritmo antes de carregar.");

        } else if (ButtonFCFS.isSelected() && !carregou) {
            carregou = true;

            try {
                FileReader arq = new FileReader(nome);
                BufferedReader lerArq = new BufferedReader(arq);
                linha = lerArq.readLine();		// lê a primeira linha
                nSetores = Integer.parseInt(linha);	// Converte pra inteiro
                linha = lerArq.readLine();		// lê a segunda  linha
                pInicial = Integer.parseInt(linha); 	// Converte para inteiro

                Processos.append("Número de Setores do HD: " + nSetores + "\n");

                Processos.append("Posição inicial do braço do HD: " + pInicial);

                Processos.append("\nTrilhas a Percorrer: " + "\n");
                //Percorre todo resto do arquivo.
                linha = lerArq.readLine(); // lê da terceira até a úlltima linha
                while (linha != null) {
                    trilha = Integer.parseInt(linha);

                    trilhasPercorridas.add(trilha);

                    Processos.append("Trilha: " + trilha + "\n");

                    linha = lerArq.readLine();

                }

            } catch (IOException e) {
                System.err.printf("Erro na abertura do arquivo: %s.\n",
                        e.getMessage());
            }

        } else if (ButtonSSF.isSelected() && !carregou) {
            carregou = true;

            try {
                FileReader arq = new FileReader(nome);
                BufferedReader lerArq = new BufferedReader(arq);

                linha = lerArq.readLine();				// lê a primeira linha
                nSetores = Integer.parseInt(linha);		// Converte pra inteiro
                linha = lerArq.readLine();				// lê a segunda  linha
                pInicial = Integer.parseInt(linha); 	// Converte para inteiro

                Processos.append("Número de Setores do HD: " + nSetores + "\n");

                Processos.append("Posição inicial do braço do HD: " + pInicial);

                trilhasPercorridas.add(pInicial);

                //Percorre todo resto do arquivo.
                linha = lerArq.readLine(); // lê da terceira até a última linha

                while (linha != null) {
                    trilha = Integer.parseInt(linha);
                    trilhasPercorridas.add(trilha);
                    linha = lerArq.readLine();
                }

                int menorDistancia = 100000;	//Colocamos um valor exorbitante(100000) para que seja garantida a primeira entrada no if.
                int trilhaAuxTemp = 0, trilhaAuxTemp2 = 0;
                int positionAux = 0;

                for (i = 0; i < (trilhasPercorridas.size() - 1); i++) {

                    //Este (for) irá rocurar a posição mais proxima da atual.
                    for (j = (i + 1); j < trilhasPercorridas.size(); j++) {
                        if (Math.abs(trilhasPercorridas.get(i) - trilhasPercorridas.get(j)) < menorDistancia) {
                            trilhaAuxTemp = trilhasPercorridas.get(j);
                            positionAux = j;
                            menorDistancia = Math.abs(trilhasPercorridas.get(i) - trilhasPercorridas.get(j));
                        }
                    }

                    //Aqui fazemos uma troca de posições do array de trilhas
                    trilhaAuxTemp2 = trilhasPercorridas.get(i + 1);
                    trilhasPercorridas.set(i + 1, trilhaAuxTemp);
                    trilhasPercorridas.set(positionAux, trilhaAuxTemp2);

                    menorDistancia = 100000;	//Colocamos um valor exorbitante(100000) para que seja garantida a primeira entrada no if.
                }

                //Imprimindo a sequencia de movimentos que será feita pelo braço
                Processos.append("\n" + "Trilhas a Percorrer: " + "\n");
                for (i = 0; i < trilhasPercorridas.size(); i++) {
                    Processos.append("Trilha: " + trilhasPercorridas.get(i) + "\n");
                }

            } catch (IOException e) {
                System.err.printf("Erro na abertura do arquivo: %s.\n",
                        e.getMessage());
            }

        } else if (ButtonElevator.isSelected() && !carregou) {
            carregou = true;

            try {
                //Lendo o arquivo dadosDisco.txt
                FileReader arq = new FileReader(nome);
                BufferedReader lerArq = new BufferedReader(arq);

                linha = lerArq.readLine();			// lê a primeira linha
                nSetores = Integer.parseInt(linha);	// Converte pra inteiro
                linha = lerArq.readLine();			// lê a segunda  linha
                pInicial = Integer.parseInt(linha); // Converte para inteiro

                Processos.append("Número de Setores do HD: " + nSetores);

                Processos.append("\n" + "Posição inicial do braço do HD: " + pInicial + "\n");

                //Percorre todo resto do arquivo.
                linha = lerArq.readLine(); 		// lê da terceira até a última linha
                while (linha != null) {
                    trilha = Integer.parseInt(linha);

                    trilhasPercorridas.add(trilha);

                    linha = lerArq.readLine(); // lê da terceira até a última linha 
                }

                trilhasPercorridas.add(pInicial);

                /**
                 *
                 * Elevator A movimentação do braço de leitura é realizada em
                 * apenas uma direção, até que a última trilha seja encontrada.
                 * Após isso a movimentação passa a ser no sentido contrário.
                 * (Por isso o nome: Elevador)
                 *
                 */
                for (i = 0; i < (trilhasPercorridas.size()); i++) {
                    for (j = i; j < (trilhasPercorridas.size()); j++) {
                        if (trilhasPercorridas.get(i) > trilhasPercorridas.get(j)) {
                            auxTrilhaTemp = trilhasPercorridas.get(i);
                            trilhasPercorridas.set(i, trilhasPercorridas.get(j));
                            trilhasPercorridas.set(j, auxTrilhaTemp);
                        }
                    }
                }

                /**
                 * Encontrando o indice da posição inicial do braço.
                 */
                for (i = 0; i < (trilhasPercorridas.size()); i++) {
                    if (pInicial == trilhasPercorridas.get(i)) {
                        init = i;
                        break;
                    }
                }

                /**
                 * Serão dois (fors) um para percorrer as trilhas na direção
                 * decrescente em relação a posição inicial do braço e outro
                 * para percorrer as trilhas na direção crescente em relação a
                 * posição inicial do braço.
                 *
                 * Perceba que ele só vai para as trilhas a  direita do braço,
                 * depois de percorrer todas as trilhas a  esqueda, ou seja,
                 * comportamento similar ao de um elevador.
                 */
                Processos.append("Trilhas a Percorrer: " + "\n");

                for (i = init; i >= 0; i--) {
                    Processos.append("Trilha: " + trilhasPercorridas.get(i) + "\n");
                    if (i > 0) {
                        difTrilhas.add(Math.abs(trilhasPercorridas.get(i) - trilhasPercorridas.get(i - 1)));
                    }

                }

                //A diferença entre a última trilha da esquerda e a primeira da direita será armazenda aqui.
                difTrilhas.add(Math.abs(trilhasPercorridas.get(init + 1) - trilhasPercorridas.get(0)));

                for (i = init + 1; i < (trilhasPercorridas.size()); i++) {
                    Processos.append("Trilha: " + trilhasPercorridas.get(i) + "\n");

                    if (i < (trilhasPercorridas.size() - 1)) {
                        difTrilhas.add(Math.abs(trilhasPercorridas.get(i) - trilhasPercorridas.get(i + 1)));
                    }

                    j++;
                }

            } catch (IOException e) {
                System.err.printf("Erro na abertura do arquivo: %s.\n",
                        e.getMessage());
            }

        }


    }//GEN-LAST:event_CarregarProcessosActionPerformed

    private void ExecutarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExecutarActionPerformed
        if (!ButtonFCFS.isSelected() && !ButtonSSF.isSelected() && !ButtonElevator.isSelected()) {
            JOptionPane.showMessageDialog(null, "Selecione um algorítimo,carregue os processos para poder executar!");
        } else if (ButtonFCFS.isSelected() && carregou) {
            somatorio = Math.abs(trilhasPercorridas.get(0) - pInicial);
            for (i = 1; i < trilhasPercorridas.size(); i++) {

                difTrilhas2 = Math.abs(trilhasPercorridas.get(i) - trilhasPercorridas.get(i - 1));

                somatorio += difTrilhas2;
            }

            TrilhasPercorridas.setText(Integer.toString(somatorio));

        } else if (ButtonSSF.isSelected() && carregou) {
            somatorio = Math.abs(trilhasPercorridas.get(0) - pInicial);

            for (i = 1; i < trilhasPercorridas.size(); i++) {

                difTrilhas2 = Math.abs(trilhasPercorridas.get(i) - trilhasPercorridas.get(i - 1));

                somatorio += difTrilhas2;
            }

            TrilhasPercorridas.setText(Integer.toString(somatorio));
        } else if (ButtonElevator.isSelected() && carregou && !executou) {
            executou = true;
            for (i = 0; i < difTrilhas.size(); i++) {
                somatorio += difTrilhas.get(i);
            }

            TrilhasPercorridas.setText(Integer.toString(somatorio));
        }
    }//GEN-LAST:event_ExecutarActionPerformed

    private void LimparActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LimparActionPerformed
        Processos.setText(null);
        TrilhasPercorridas.setText(null);
        carregou = false;
        linha = "";			//Variável auxiliar que captura a linha do arquivo;
        nSetores = 0;			//Número de Setores do HD
        pInicial = 0;			//Posição inicial do braço do HD
        trilha = 0;			//Indica a trilha do HD
        i = 1;
        somatorio = 0;
        j = 0;
        auxTrilhaTemp = 0;
        init = 0;
        difTrilhas2 = 0;
        trilhasPercorridas.clear();
        difTrilhas.clear();
        executou = false;
    }//GEN-LAST:event_LimparActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Tela.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Tela.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Tela.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Tela.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Tela().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton ButtonElevator;
    private javax.swing.JRadioButton ButtonFCFS;
    private javax.swing.JRadioButton ButtonSSF;
    private javax.swing.JButton CarregarProcessos;
    private javax.swing.JButton Executar;
    private javax.swing.JButton Limpar;
    private javax.swing.JTextArea Processos;
    private javax.swing.JTextPane TrilhasPercorridas;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.ButtonGroup buttonGroup2;
    private javax.swing.ButtonGroup buttonGroup3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables
}
